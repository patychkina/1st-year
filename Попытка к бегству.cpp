/*Узник пытается бежать из замка, который состоит из N×M квадратных комнат, расположенных в виде прямоугольника NxM. 
Между любыми двумя соседними комнатами есть дверь, однако некоторые комнаты закрыты и попасть в них нельзя. 
В начале узник находится в левой верхней комнате и для спасения ему надо попасть в противоположную правую нижнюю комнату. 
Времени у него немного, всего он может побывать не более, чем в N+M-1 комнате на своем пути, то есть 
перемещаться он должен только вправо или вниз. Определите количество маршрутов, которые ведут к выходу.

Входные данные
Первая строчка входных данных содержит натуральные числа N и M, не превосходящих 1000. Далее идет план замка в 
виде N строчек из M чисел в каждой. Одно число соответствует одной комнате: 1 означает, что в комнату можно попасть,
 0 – что комната закрыта.

Выходные данные
Программа должна напечатать количество маршрутов, ведущих узника к выходу и проходящих через M+N-1 комнату,
 или слово Impossible, если таких маршрутов не существует.

Входные данные подобраны таким образом, что искомое число маршрутов не превосходит 2.000.000.000.*/

#include <iostream>
#include <vector>
using namespace std;

int main()
{
	int N, M;
	cin >> N >> M;
	vector <vector <long>> castle(N + 1, vector <long>(M + 1));
	vector <vector <long>> number_of_routes(N + 1, vector <long>(M + 1));
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= M; j++)
			cin >> castle[i][j];
	}
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= M; j++)
		{
			if (i == 1 && j == 1)
				number_of_routes[i][j] = castle[i][j];
			else
			{
				if (castle[i - 1][j] != 0)
					number_of_routes[i][j] += number_of_routes[i - 1][j];
				if (castle[i][j - 1] != 0)
					number_of_routes[i][j] += number_of_routes[i][j - 1];
			}
		}
	}
	if (number_of_routes[N][M] == 0)
		cout << "Impossible" << endl;
	else
		cout << number_of_routes[N][M] << endl;
}