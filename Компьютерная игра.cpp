/*Вы можете вспомнить хоть одного своего знакомого до двадцатилетнего возраста,
 который в детстве не играл в компьютерные игры? Если да, то может быть вы и сами 
 не знакомы с этим развлечением? Впрочем, трудностей при решении этой задачи это создать не должно.

Во многих старых играх с двумерной графикой можно столкнуться с подобной ситуацией.
 Какой-нибудь герой прыгает по платформам (или островкам), которые висят в воздухе. 
 Он должен перебраться от одного края экрана до другого. При этом при прыжке 
 с одной платформы на соседнюю, у героя уходит |y2-y1| единиц энергии, где y1 и y2 – 
 высоты, на которых расположены эти платформы. Кроме того, у героя есть суперприем, 
 который позволяет перескочить через платформу, но на это затрачивается 3*|y3-y1| единиц энергии.
  Конечно же, энергию следует расходовать максимально экономно.

Предположим, что вам известны координаты всех платформ в порядке от левого края до правого.
 Сможете ли вы найти, какое минимальное количество энергии потребуется герою, чтобы добраться с первой платформы до последней?

Входные данные
В первой строке входного файла INPUT.TXT записано количество платформ n (1 ≤ n ≤ 30000). 
Вторая строка содержит n натуральных чисел, не превосходящих 30000 – высоты, на которых располагаются платформы.

Выходные данные
В выходной файл OUTPUT.TXT запишите единственное число – минимальное количество энергии,
 которую должен потратить игрок на преодоление платформ (конечно же в предположении, 
 что cheat-коды использовать нельзя).*/
 
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

int main()
{
	int N;
	cin >> N;
	vector <int> v_height(N);
	vector <int> v_energy(N);
	for (int i = 0; i < N; i++)
		cin >> v_height[i];
	v_energy[0] = 0;
	v_energy[1] = abs(v_height[1] - v_height[0]);
	for (int i = 2; i < N; i++)
	{
		int min_v = abs(v_height[i] - v_height[i - 1]) + v_energy[i - 1];
		min_v = min(min_v, 3 * abs(v_height[i] - v_height[i - 2]) + v_energy[i - 2]);
		v_energy[i] = min_v;
	}
	cout << v_energy[N - 1] << endl;
}